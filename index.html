<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple Driving Simulator</title>
<style>
  html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background:#111; color:#eee; display:flex; align-items:center; justify-content:center; }
  #gameWrap { width:900px; max-width:95vw; background:linear-gradient(#222,#1b1b1b); padding:12px; border-radius:10px; box-shadow:0 8px 30px rgba(0,0,0,0.7); }
  canvas { display:block; background: #2b6c2b; border-radius:6px; }
  .hud { margin-top:8px; display:flex; gap:12px; align-items:center; }
  .panel { background:rgba(255,255,255,0.04); padding:8px 12px; border-radius:8px; font-size:14px; }
  button { background:#0b84ff; border:0; color:white; padding:8px 12px; border-radius:6px; cursor:pointer; }
  button:active { transform:translateY(1px); }
  small { color:#bfcbdc; display:block; margin-top:4px; font-size:12px; }
  .controls { font-size:13px; color:#cfe; }
</style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="world" width="800" height="500"></canvas>
    <div class="hud">
      <div class="panel">
        <div>Speed: <span id="speed">0</span> px/s</div>
        <div>Angle: <span id="angle">0</span>°</div>
        <div>Collisions: <span id="collisions">0</span></div>
      </div>
      <div class="panel">
        <button id="resetBtn">Reset</button>
        <button id="toggleMap">Toggle Mini-map</button>
        <small class="controls">Controls: ↑ / W = accelerate, ↓ / S = brake/reverse, ← / A = steer left, → / D = steer right, R = reset</small>
      </div>
    </div>
  </div>

<script>
/* Simple top-down driving simulator
   - Car has continuous position, velocity, angle
   - Friction slows down
   - Steering rotates car at speed-dependent rate
   - Axis-aligned obstacle collision (simple response)
*/

const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');

const W = canvas.width, H = canvas.height;

// World objects
const obstacles = [
  {x:200, y:120, w:120, h:60},
  {x:420, y:300, w:200, h:30},
  {x:80,  y:320, w:100, h:100}
];

// Car
const car = {
  x: 120,
  y: 80,
  angle: 0,           // radians
  width: 28,
  length: 48,
  vel: 0,             // speed scalar (px per second)
  maxSpeed: 420,
  accel: 600,         // px/s^2
  brake: 900,
  friction: 400,      // px/s^2 natural friction
  steerSpeed: Math.PI, // rad/s at full effect
  collisions: 0
};

// Input state
const input = {
  up:false, down:false, left:false, right:false
};

let showMiniMap = true;

// Time
let last = performance.now();

// HTML HUD nodes
const speedNode = document.getElementById('speed');
const angleNode = document.getElementById('angle');
const collNode  = document.getElementById('collisions');
document.getElementById('resetBtn').onclick = reset;
document.getElementById('toggleMap').onclick = ()=>{ showMiniMap = !showMiniMap; };

// Keyboard
window.addEventListener('keydown', e=>{
  const k = e.key.toLowerCase();
  if(k==='arrowup' || k==='w') input.up = true;
  if(k==='arrowdown' || k==='s') input.down = true;
  if(k==='arrowleft' || k==='a') input.left = true;
  if(k==='arrowright' || k==='d') input.right = true;
  if(k==='r') reset();
});
window.addEventListener('keyup', e=>{
  const k = e.key.toLowerCase();
  if(k==='arrowup' || k==='w') input.up = false;
  if(k==='arrowdown' || k==='s') input.down = false;
  if(k==='arrowleft' || k==='a') input.left = false;
  if(k==='arrowright' || k==='d') input.right = false;
});

// Helper
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// Main loop
function loop(t){
  const dt = Math.min(0.05, (t - last)/1000); // cap dt to avoid jumps
  last = t;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// Physics update
function update(dt){
  // Acceleration / braking
  if(input.up){
    car.vel += car.accel * dt;
  } else if(input.down){
    car.vel -= car.brake * dt;
  } else {
    // natural friction
    if(car.vel > 0) {
      car.vel -= car.friction*dt;
      if(car.vel < 0) car.vel = 0;
    } else if(car.vel < 0) {
      car.vel += car.friction*dt;
      if(car.vel > 0) car.vel = 0;
    }
  }

  // clamp speed
  car.vel = clamp(car.vel, -car.maxSpeed*0.5, car.maxSpeed);

  // Steering effectiveness reduced at very low speeds
  const speedFactor = clamp(Math.abs(car.vel) / car.maxSpeed, 0, 1);
  const steerEffect = 1 - Math.exp(-3*speedFactor); // ramps up with speed

  // Steering direction: reverse steering steers opposite if going backward
  const steerDir = (car.vel >= 0) ? 1 : -1;
  if(input.left){
    car.angle -= car.steerSpeed * steerEffect * dt * steerDir;
  }
  if(input.right){
    car.angle += car.steerSpeed * steerEffect * dt * steerDir;
  }

  // Integrate position
  const dx = Math.cos(car.angle) * car.vel * dt;
  const dy = Math.sin(car.angle) * car.vel * dt;
  car.x += dx;
  car.y += dy;

  // World bounds collision: simple clamp + bounce reduction
  let collided = false;
  const halfW = car.length/2, halfH = car.width/2;
  if(car.x < halfW){ car.x = halfW; car.vel *= -0.25; collided = true; }
  if(car.x > W - halfW){ car.x = W - halfW; car.vel *= -0.25; collided = true; }
  if(car.y < halfW){ car.y = halfW; car.vel *= -0.25; collided = true; }
  if(car.y > H - halfW){ car.y = H - halfW; car.vel *= -0.25; collided = true; }

  // Obstacle collisions (approximate by AABB on car's bounding box)
  // Build axis-aligned bounding box around rotated car (approximation)
  const carBBox = getCarAABB();

  for(const ob of obstacles){
    if(aabbIntersect(carBBox, ob)){
      // On collision, push car away along smallest penetration axis
      const pen = getPenetration(carBBox, ob);
      if(Math.abs(pen.x) < Math.abs(pen.y)){
        car.x += pen.x;
      } else {
        car.y += pen.y;
      }
      car.vel *= -0.35; // lose speed and bounce a bit
      collided = true;
    }
  }

  if(collided){ car.collisions++; }

  // Update HUD
  speedNode.textContent = Math.round(car.vel);
  angleNode.textContent = Math.round((car.angle * 180/Math.PI) % 360);
  collNode.textContent = car.collisions;
}

function getCarAABB(){
  // compute four corners of the car rectangle and make AABB
  const l = car.length, w = car.width;
  const cos = Math.cos(car.angle), sin = Math.sin(car.angle);
  const hx = l/2, hy = w/2;
  const corners = [
    {x: car.x + cos* hx - sin* hy, y: car.y + sin* hx + cos* hy},
    {x: car.x - cos* hx - sin* hy, y: car.y - sin* hx + cos* hy},
    {x: car.x - cos* hx + sin* hy, y: car.y - sin* hx - cos* hy},
    {x: car.x + cos* hx + sin* hy, y: car.y + sin* hx - cos* hy}
  ];
  const xs = corners.map(p=>p.x), ys = corners.map(p=>p.y);
  const minx = Math.min(...xs), maxx = Math.max(...xs);
  const miny = Math.min(...ys), maxy = Math.max(...ys);
  return {x:minx,y:miny,w:maxx-minx,h:maxy-miny};
}

function aabbIntersect(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

function getPenetration(a,b){
  // returns minimal translation vector to separate a from b (approx)
  const axc = a.x + a.w/2, ayc = a.y + a.h/2;
  const bxc = b.x + b.w/2, byc = b.y + b.h/2;
  const dx = axc - bxc;
  const dy = ayc - byc;
  const px = (a.w + b.w)/2 - Math.abs(dx);
  const py = (a.h + b.h)/2 - Math.abs(dy);
  if(px < py){
    return {x: dx > 0 ? px : -px, y:0};
  } else {
    return {x:0, y: dy > 0 ? py : -py};
  }
}

// Rendering
function render(){
  ctx.clearRect(0,0,W,H);

  // draw ground grid (simple)
  drawGrid();

  // draw obstacles
  ctx.fillStyle = '#6b4b3b';
  for(const ob of obstacles){
    roundRect(ctx, ob.x, ob.y, ob.w, ob.h, 6);
    ctx.fill();
  }

  // draw car: rotated rectangle + simple windows/stripe
  ctx.save();
  ctx.translate(car.x, car.y);
  ctx.rotate(car.angle);
  // body
  ctx.fillStyle = '#e23f3f';
  roundRect(ctx, -car.length/2, -car.width/2, car.length, car.width, 4);
  ctx.fill();
  // stripe
  ctx.fillStyle = '#222';
  ctx.fillRect(-car.length/6, -car.width/5, car.length/3, car.width/2.5);
  // front indicator
  ctx.fillStyle = '#ffd868';
  ctx.fillRect(car.length/2 - 6, -car.width/6, 6, car.width/3);
  ctx.restore();

  // draw a simple shadow under car
  ctx.beginPath();
  ctx.ellipse(car.x, car.y + car.width, car.length*0.5, car.width*0.6, 0, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.fill();

  // mini-map
  if(showMiniMap){
    drawMiniMap();
  } else {
    // draw small hint
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(W-160, H-80, 150, 60);
    ctx.fillStyle = '#fff';
    ctx.font = '12px sans-serif';
    ctx.fillText('Mini-map hidden. Click Toggle Mini-map.', W-150, H-50);
  }
}

function drawGrid(){
  const size = 40;
  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  for(let x=0;x<=W;x+=size){
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x,H);
    ctx.stroke();
  }
  for(let y=0;y<=H;y+=size){
    ctx.beginPath();
    ctx.moveTo(0,y);
    ctx.lineTo(W,y);
    ctx.stroke();
  }
  ctx.restore();
}

function drawMiniMap(){
  const mw = 150, mh = 90;
  const mx = W - mw - 8, my = H - mh - 8;
  // background
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  roundRect(ctx, mx, my, mw, mh, 8);
  ctx.fill();

  // scale world to minimap (simple 1: scale)
  const sx = mw / W, sy = mh / H;

  // obstacles
  ctx.save();
  ctx.translate(mx, my);
  ctx.scale(sx, sy);
  ctx.fillStyle = '#b36b4b';
  for(const ob of obstacles){
    ctx.fillRect(ob.x+1, ob.y+1, ob.w-2, ob.h-2);
  }
  // car as triangle on mini-map
  ctx.translate(car.x, car.y);
  ctx.rotate(car.angle);
  ctx.beginPath();
  ctx.moveTo(10,0);
  ctx.lineTo(-6,6);
  ctx.lineTo(-6,-6);
  ctx.closePath();
  ctx.fillStyle = '#ffeb3b';
  ctx.fill();

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

// Reset to start
function reset(){
  car.x = 120;
  car.y = 80;
  car.angle = 0;
  car.vel = 0;
  car.collisions = 0;
}

// Start loop
reset();
requestAnimationFrame(loop);

</script>
</body>
</html>
